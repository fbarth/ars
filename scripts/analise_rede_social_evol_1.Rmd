Pequeno exemplo sobre Análise de Redes Sociais (evolução 1)
========================================================

O objetivo deste documento é exemplificar o cálculo de atributos de redes sociais. Os exemplos foram implementados utilizando a linguagem de programação *R* e o pacote *igraph* (http://igraph.org/r/doc/).

```{r}
library(igraph)
relacoes <- read.csv('../data//relacoes_evol1.csv', sep=';')
g <- graph.data.frame(relacoes, directed=TRUE)
```


O grafo didático criado possui a seguinte estrutura:

```{r fig.width=7, fig.height=6}
plot(g, layout=layout.kamada.kawai, edge.width=E(g)$weight, edge.color="black")
```

````{r}
qtd_vertice <- vcount(g)
qtd_vertice
qtd_aresta <- ecount(g)
qtd_aresta
is.connected(g)
````

O grafo possui `r qtd_vertice` nodos, `r qtd_aresta` arestas e não é conectado.

O _longest path_ do grafo e os nodos que estão mais longe entre si são apresentados abaixo:

````{r}
diam <- diameter(g)
diam
nodes <- farthest.nodes(g)
nodes
V(g)[nodes[1]]
V(g)[nodes[2]]
````

Um atributo utilizado para medir a eficiência do tráfego de informação de uma rede é o _average path length_.
_average path length_ é definido como o número médio de passos entre os menores caminhos para todos os pares
de nodos possíveis na rede. Quanto menor este número, maior é a eficiência do tráfego de informação na rede.

Podemos calcular o _average path length_ de duas formas:

* considerando apenas o comprimento dos caminhos existentes:

````{r}  
aver_path <- average.path.length(g, directed=TRUE, unconnected=TRUE)
aver_path
````

* considerando também os caminhos faltantes. Neste caso, considera-se o tamanho de um caminho faltante como sendo _vcount(graph)_. 

````{r}  
aver_path <- average.path.length(g, directed=TRUE, unconnected=FALSE)
aver_path
````

O número de seguidores (in-degree), o número de seguidos (out-degree) e o número de conexões de uma pessoa podem ser facilmente calculados da seguinte forma:

````{r}
degree(g, mode="in")
degree(g, mode="out")
degree(g, mode="all")
````

Betweenness is a centrality measure of a vertex within a graph (there is also edge betweenness, which is not discussed here). Betweenness centrality quantifies the number of times a node acts as a bridge along the shortest path between two other nodes. It was introduced as a measure for quantifying the control of a human on the communication between other humans in a social network by Linton Freeman[16] In his conception, vertices that have a high probability to occur on a randomly chosen shortest path between two randomly chosen vertices have a high betweenness.

Betweenness centrality is an indicator of a node's centrality in a network. It is equal to the number of shortest paths from all vertices to all others that pass through that node.  Betweenness centrality is a more useful measure (than just connectivity) of both the load and importance of a node.

````{r}
betweenness <- betweenness(g, directed=TRUE)
which.max(betweenness)
which.min(betweenness)
````


A _reciprocity_ de um usuário é calculado como $R(x) = \frac{|Out(x) \in In(x)|}{|Out(x)|}$ onde $Out(x)$ é o conjunto de usuários que o usuário $x$ segue e $In(x)$ é o conjunto de usuários que segue $x$. _Reciprocity_ mede a probabilidade de um usuário ser seguido por usuários que ele segue.

````{r}
# estah me retornando a reciprocity do grafo. 
# ver como retornar o valor para cada usuário.
reciprocity(g)
````

A _assortativity_ de um nodo é definido como a razão entre o (in/out) degree e a média do (in/out) degree dos seus vizinhos. Podemos calcular a _assortativity_ para quatro tipos de degree-degree correlação (i.e., in-in, in-out, out-in e out-out).

````{r}
assortativity.degree(g)
````

Autoridades e hubs:

````{r}
authority_values <- authority.score(g)$vector
authority_values
which.max(authority_values)
which.min(authority_values)
hub_values <- hub.score(g)$vector
hub_values
which.max(hub_values)
which.min(hub_values)
````

Pagerank:

````{r}
page_rank_values <- page.rank(g)$vector
page_rank_values
which.max(page_rank_values)
which.min(page_rank_values)
````

Clusters
--------

````{r}
cl <- clusters(g)
quantidade_clusters <- cl$no
quantidade_clusters
````

````{r fig.width=7, fig.height=6}
plot(g, layout=layout.kamada.kawai, 
     edge.width=E(g)$width, 
     edge.color="black", 
     vertex.color=cl$membership)
````